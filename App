"""
Stock Trading Dashboard - Streamlit Application
================================================
A comprehensive stock screening and analysis dashboard with real-time data,
technical indicators, and historical tracking.

Author: Claude AI Assistant
Version: 4.0 - Pro Edition with Risk Management & AI Insights
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import yfinance as yf
from datetime import datetime, timedelta
import sqlite3
from typing import List, Dict, Optional, Tuple
import warnings
import time
import re
import requests
import json
from streamlit_gsheets import GSheetsConnection

warnings.filterwarnings('ignore')

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def clean_ticker_list(ticker_input: str) -> List[str]:
    """
    Clean and parse ticker list from user input
    
    Args:
        ticker_input: Comma-separated ticker string
    
    Returns:
        List of cleaned ticker symbols
    """
    if not ticker_input:
        return []
    
    # Split by comma and clean each ticker
    tickers = [
        re.sub(r'[^A-Z0-9\-.]', '', ticker.strip().upper())
        for ticker in ticker_input.split(',')
    ]
    
    # Remove empty strings and duplicates while preserving order
    seen = set()
    cleaned_tickers = []
    for ticker in tickers:
        if ticker and ticker not in seen:
            seen.add(ticker)
            cleaned_tickers.append(ticker)
    
    return cleaned_tickers

# ============================================================================
# DATABASE LAYER
# ============================================================================

class DatabaseManager:
    """Manages SQLite database operations for scan history"""
    
    def __init__(self, db_path: str = "scan_history.db"):
        self.db_path = db_path
        self.init_db()
    
    def init_db(self):
        """Initialize database with scans table"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_time DATETIME NOT NULL,
                ticker TEXT NOT NULL,
                close REAL,
                score INTEGER,
                sentiment REAL,
                signal TEXT,
                rsi REAL,
                volume REAL,
                sma_20 REAL,
                sma_50 REAL
            )
        """)
        
        conn.commit()
        conn.close()
    
    def save_scan_results(self, results: List[Dict]):
        """Save scan results to database"""
        if not results:
            return
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        scan_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        for result in results:
            cursor.execute("""
                INSERT INTO scans (scan_time, ticker, close, score, sentiment, 
                                  signal, rsi, volume, sma_20, sma_50)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                scan_time,
                result.get('ticker', ''),
                result.get('close', 0),
                result.get('score', 0),
                result.get('sentiment', 0),
                result.get('signal', 'HOLD'),
                result.get('rsi', 50),
                result.get('volume', 0),
                result.get('sma_20', 0),
                result.get('sma_50', 0)
            ))
        
        conn.commit()
        conn.close()
    
    def load_latest_scan(self) -> pd.DataFrame:
        """Load most recent scan results"""
        conn = sqlite3.connect(self.db_path)
        
        query = """
            SELECT ticker, close, score, sentiment, signal, rsi, volume, 
                   sma_20, sma_50, scan_time
            FROM scans
            WHERE scan_time = (SELECT MAX(scan_time) FROM scans)
            ORDER BY score DESC
        """
        
        df = pd.read_sql_query(query, conn)
        conn.close()
        
        return df
    
    def load_history(self, ticker: str) -> pd.DataFrame:
        """Load historical scans for a specific ticker"""
        conn = sqlite3.connect(self.db_path)
        
        query = """
            SELECT scan_time, close, score, sentiment, signal, rsi, volume
            FROM scans
            WHERE ticker = ?
            ORDER BY scan_time DESC
            LIMIT 50
        """
        
        df = pd.read_sql_query(query, conn, params=(ticker,))
        conn.close()
        
        return df

# ============================================================================
# MARKET DATA SERVICE
# ============================================================================

@st.cache_data(ttl=300)  # Cache for 5 minutes
def fetch_stock_data(ticker: str, period: str = "3mo") -> Optional[pd.DataFrame]:
    """
    Fetch stock price data using yfinance
    
    Args:
        ticker: Stock ticker symbol
        period: Time period (1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, max)
    
    Returns:
        DataFrame with OHLCV data or None if error
    """
    try:
        stock = yf.Ticker(ticker)
        df = stock.history(period=period)
        
        if df.empty:
            return None
        
        return df
    except Exception as e:
        st.error(f"Error fetching data for {ticker}: {str(e)}")
        return None

@st.cache_data(ttl=300)
def fetch_stock_info(ticker: str) -> Dict:
    """Fetch stock information and metrics"""
    try:
        stock = yf.Ticker(ticker)
        info = stock.info
        return info
    except:
        return {}

# ============================================================================
# PERPLEXITY AI INTEGRATION
# ============================================================================

@st.cache_data(ttl=3600)  # Cache for 1 hour
def fetch_ai_sentiment(ticker: str, perplexity_api_key: str) -> Optional[str]:
    """
    Fetch AI-powered sentiment analysis from Perplexity
    
    Args:
        ticker: Stock ticker symbol
        perplexity_api_key: Perplexity API key
    
    Returns:
        AI sentiment summary (up to 280 chars) or None
    """
    if not perplexity_api_key:
        return None
    
    try:
        url = "https://api.perplexity.ai/chat/completions"
        
        # Focused query for sentiment and recent reports
        query = f"Analyze {ticker} stock: What's the current fundamental sentiment based on latest earnings reports, analyst ratings, and recent news? Summarize in 2-3 sentences (max 280 chars)."
        
        headers = {
            "Authorization": f"Bearer {perplexity_api_key}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": "llama-3.1-sonar-small-128k-online",
            "messages": [
                {
                    "role": "system",
                    "content": "You are a financial analyst providing concise stock sentiment analysis."
                },
                {
                    "role": "user",
                    "content": query
                }
            ],
            "temperature": 0.2,
            "max_tokens": 100
        }
        
        response = requests.post(url, headers=headers, json=payload, timeout=15)
        
        if response.status_code != 200:
            return None
        
        data = response.json()
        
        # Extract the response
        if 'choices' in data and len(data['choices']) > 0:
            sentiment = data['choices'][0]['message']['content']
            
            # Truncate to 280 characters
            if len(sentiment) > 280:
                sentiment = sentiment[:277] + "..."
            
            return sentiment
        
        return None
    
    except Exception as e:
        return None

# ============================================================================
# GOOGLE SHEETS TREND TRACKING
# ============================================================================

def init_gsheets_connection() -> Optional[GSheetsConnection]:
    """Initialize Google Sheets connection"""
    try:
        conn = st.connection("gsheets", type=GSheetsConnection)
        return conn
    except Exception as e:
        st.warning(f"Google Sheets connection not configured: {str(e)}")
        return None

def save_score_to_gsheets(conn: GSheetsConnection, ticker: str, score: int, date: str):
    """Save score to Google Sheets for trend tracking"""
    if not conn:
        return
    
    try:
        # Read existing data
        df = conn.read(worksheet="Scores", usecols=[0, 1, 2])
        
        # Append new row
        new_row = pd.DataFrame({
            'Date': [date],
            'Ticker': [ticker],
            'Score': [score]
        })
        
        updated_df = pd.concat([df, new_row], ignore_index=True)
        
        # Write back
        conn.update(worksheet="Scores", data=updated_df)
    
    except Exception as e:
        # If worksheet doesn't exist, create it
        try:
            new_df = pd.DataFrame({
                'Date': [date],
                'Ticker': [ticker],
                'Score': [score]
            })
            conn.update(worksheet="Scores", data=new_df)
        except:
            pass  # Silently fail if can't create

def get_score_history_gsheets(conn: GSheetsConnection, ticker: str, days: int = 7) -> pd.DataFrame:
    """Get score history from Google Sheets"""
    if not conn:
        return pd.DataFrame()
    
    try:
        # Read data
        df = conn.read(worksheet="Scores", usecols=[0, 1, 2])
        
        # Filter by ticker
        df = df[df['Ticker'] == ticker]
        
        # Convert date and filter last N days
        df['Date'] = pd.to_datetime(df['Date'])
        cutoff_date = datetime.now() - timedelta(days=days)
        df = df[df['Date'] >= cutoff_date]
        
        # Sort by date
        df = df.sort_values('Date')
        
        return df[['Date', 'Score']]
    
    except:
        return pd.DataFrame()

def create_sparkline(scores: List[float], width: int = 100, height: int = 30) -> str:
    """
    Create a simple SVG sparkline
    
    Args:
        scores: List of score values
        width: Width of sparkline in pixels
        height: Height of sparkline in pixels
    
    Returns:
        SVG string for sparkline
    """
    if not scores or len(scores) < 2:
        return ""
    
    # Normalize scores to fit in height
    min_score = min(scores)
    max_score = max(scores)
    score_range = max_score - min_score if max_score > min_score else 1
    
    # Calculate points
    x_step = width / (len(scores) - 1)
    points = []
    
    for i, score in enumerate(scores):
        x = i * x_step
        # Invert y because SVG coordinates start from top
        y = height - ((score - min_score) / score_range * height)
        points.append(f"{x:.1f},{y:.1f}")
    
    polyline = " ".join(points)
    
    # Determine color based on trend
    trend_color = "#28a745" if scores[-1] >= scores[0] else "#dc3545"
    
    svg = f'''
    <svg width="{width}" height="{height}" style="vertical-align: middle;">
        <polyline points="{polyline}" 
                  fill="none" 
                  stroke="{trend_color}" 
                  stroke-width="2"/>
    </svg>
    '''
    
    return svg

# ============================================================================
# FUNDAMENTAL DATA SERVICE (ALPHA VANTAGE)
# ============================================================================

@st.cache_data(ttl=86400)  # Cache for 24 hours
def fetch_fundamental_data(ticker: str, api_key: str) -> Optional[Dict]:
    """
    Fetch fundamental data from Alpha Vantage
    
    Args:
        ticker: Stock ticker symbol
        api_key: Alpha Vantage API key
    
    Returns:
        Dictionary with P/E, PEG, Revenue Growth, etc.
    """
    if not api_key:
        # Fallback to yfinance for basic fundamentals
        try:
            stock = yf.Ticker(ticker)
            info = stock.info
            
            return {
                'pe_ratio': info.get('trailingPE', None),
                'peg_ratio': info.get('pegRatio', None),
                'revenue_growth': info.get('revenueGrowth', None),
                'profit_margin': info.get('profitMargins', None),
                'beta': info.get('beta', 1.0),
                'market_cap': info.get('marketCap', 0),
                'source': 'yfinance'
            }
        except:
            return None
    
    # Use Alpha Vantage if API key is provided
    try:
        # Overview endpoint
        url = f"https://www.alphavantage.co/query?function=OVERVIEW&symbol={ticker}&apikey={api_key}"
        response = requests.get(url, timeout=10)
        
        if response.status_code != 200:
            return None
        
        data = response.json()
        
        if not data or 'Symbol' not in data:
            return None
        
        # Parse fundamental metrics
        return {
            'pe_ratio': float(data.get('PERatio', 0)) if data.get('PERatio') else None,
            'peg_ratio': float(data.get('PEGRatio', 0)) if data.get('PEGRatio') else None,
            'revenue_growth': float(data.get('QuarterlyRevenueGrowthYOY', 0)) if data.get('QuarterlyRevenueGrowthYOY') else None,
            'profit_margin': float(data.get('ProfitMargin', 0)) if data.get('ProfitMargin') else None,
            'beta': float(data.get('Beta', 1.0)) if data.get('Beta') else 1.0,
            'market_cap': float(data.get('MarketCapitalization', 0)) if data.get('MarketCapitalization') else 0,
            'eps': float(data.get('EPS', 0)) if data.get('EPS') else None,
            'book_value': float(data.get('BookValue', 0)) if data.get('BookValue') else None,
            'source': 'alpha_vantage'
        }
    
    except Exception as e:
        # Fallback to yfinance
        try:
            stock = yf.Ticker(ticker)
            info = stock.info
            
            return {
                'pe_ratio': info.get('trailingPE', None),
                'peg_ratio': info.get('pegRatio', None),
                'revenue_growth': info.get('revenueGrowth', None),
                'profit_margin': info.get('profitMargins', None),
                'beta': info.get('beta', 1.0),
                'market_cap': info.get('marketCap', 0),
                'source': 'yfinance_fallback'
            }
        except:
            return None

# ============================================================================
# TECHNICAL INDICATORS
# ============================================================================

def calculate_rsi(data: pd.Series, period: int = 14) -> pd.Series:
    """Calculate Relative Strength Index"""
    delta = data.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    
    return rsi

def calculate_sma(data: pd.Series, period: int) -> pd.Series:
    """Calculate Simple Moving Average"""
    return data.rolling(window=period).mean()

def calculate_atr(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> pd.Series:
    """
    Calculate Average True Range (ATR) without TA-Lib
    
    Args:
        high: High prices
        low: Low prices
        close: Close prices
        period: ATR period (default 14)
    
    Returns:
        Series with ATR values
    """
    # True Range calculation
    high_low = high - low
    high_close = np.abs(high - close.shift())
    low_close = np.abs(low - close.shift())
    
    # True Range is the maximum of the three
    true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    
    # ATR is the moving average of True Range
    atr = true_range.rolling(window=period).mean()
    
    return atr

def detect_volume_spike(volume: pd.Series, threshold: float = 1.5) -> bool:
    """Detect if current volume is significantly higher than average"""
    if len(volume) < 20:
        return False
    
    avg_volume = volume[-20:].mean()
    current_volume = volume.iloc[-1]
    
    return current_volume > (avg_volume * threshold)

def detect_breakout(close: pd.Series, high: pd.Series) -> bool:
    """Detect if stock is breaking out of recent range"""
    if len(close) < 20:
        return False
    
    recent_high = high[-20:-1].max()
    current_close = close.iloc[-1]
    
    return current_close > recent_high

# ============================================================================
# RISK MANAGEMENT ENGINE
# ============================================================================

def calculate_position_size(
    account_size: float,
    risk_percent: float,
    entry_price: float,
    stop_loss: float
) -> Dict:
    """
    Calculate position size based on risk management rules
    
    Args:
        account_size: Total account size in dollars
        risk_percent: Risk percentage per trade (e.g., 2.0 for 2%)
        entry_price: Intended entry price
        stop_loss: Stop loss price
    
    Returns:
        Dictionary with position size details
    """
    # Calculate risk amount in dollars
    risk_amount = account_size * (risk_percent / 100)
    
    # Calculate risk per share
    risk_per_share = abs(entry_price - stop_loss)
    
    if risk_per_share == 0:
        return {
            'shares': 0,
            'position_value': 0,
            'risk_amount': risk_amount,
            'risk_per_share': 0
        }
    
    # Calculate number of shares
    shares = int(risk_amount / risk_per_share)
    
    # Calculate position value
    position_value = shares * entry_price
    
    return {
        'shares': shares,
        'position_value': round(position_value, 2),
        'risk_amount': round(risk_amount, 2),
        'risk_per_share': round(risk_per_share, 2)
    }

def calculate_atr_stop_loss(close: float, atr: float, multiplier: float = 1.5) -> float:
    """
    Calculate stop loss based on ATR
    
    Args:
        close: Current price
        atr: Average True Range
        multiplier: ATR multiplier (default 1.5)
    
    Returns:
        Stop loss price
    """
    stop_loss = close - (atr * multiplier)
    return round(max(stop_loss, 0), 2)  # Ensure non-negative

# ============================================================================
# EXPERT SCORING ENGINE
# ============================================================================

def calculate_expert_score(
    rsi: float,
    close: float,
    sma_20: float,
    sma_50: float,
    volume_spike: bool,
    breakout: bool,
    fundamental_data: Optional[Dict],
    rsi_low: int = 30,
    rsi_high: int = 70
) -> Tuple[int, str, str]:
    """
    Calculate expert score combining technical and fundamental analysis
    
    Args:
        rsi: RSI value
        close: Current price
        sma_20: 20-day simple moving average
        sma_50: 50-day simple moving average
        volume_spike: Volume spike detected
        breakout: Breakout detected
        fundamental_data: Dictionary with P/E, PEG, etc.
        rsi_low: Oversold threshold
        rsi_high: Overbought threshold
    
    Returns:
        Tuple of (score, signal, recommendation)
    """
    score = 50  # Base score
    
    # ========================================
    # TECHNICAL ANALYSIS (60% weight)
    # ========================================
    
    # RSI component (20 points)
    if rsi < rsi_low:
        score += 20  # Oversold - bullish
    elif rsi > rsi_high:
        score -= 20  # Overbought - bearish
    elif 40 <= rsi <= 60:
        score += 5  # Neutral zone is slightly positive
    
    # Moving average component (15 points)
    if close > sma_20 > sma_50:
        score += 15  # Strong bullish trend
    elif close > sma_20 and close > sma_50:
        score += 10  # Moderate bullish
    elif close < sma_20 < sma_50:
        score -= 15  # Strong bearish trend
    elif close < sma_20 and close < sma_50:
        score -= 10  # Moderate bearish
    
    # Volume spike (10 points)
    if volume_spike:
        score += 10
    
    # Breakout (10 points)
    if breakout:
        score += 10
    
    # Price momentum (5 points)
    if sma_20 > 0 and sma_50 > 0:
        price_above_sma20 = ((close - sma_20) / sma_20) * 100
        if price_above_sma20 > 5:
            score += 5
        elif price_above_sma20 < -5:
            score -= 5
    
    # ========================================
    # FUNDAMENTAL ANALYSIS (40% weight)
    # ========================================
    
    if fundamental_data:
        # PEG Ratio (15 points) - Most important fundamental metric
        peg = fundamental_data.get('peg_ratio')
        if peg is not None and peg > 0:
            if peg < 1.0:
                score += 15  # Undervalued
            elif peg < 1.5:
                score += 10  # Fair value
            elif peg < 2.0:
                score += 5  # Slightly overvalued
            elif peg > 3.0:
                score -= 10  # Significantly overvalued
        
        # P/E Ratio (10 points)
        pe = fundamental_data.get('pe_ratio')
        if pe is not None and pe > 0:
            if pe < 15:
                score += 10  # Very attractive
            elif pe < 25:
                score += 5  # Reasonable
            elif pe > 40:
                score -= 10  # Expensive
        
        # Revenue Growth (10 points)
        revenue_growth = fundamental_data.get('revenue_growth')
        if revenue_growth is not None:
            if revenue_growth > 0.20:  # 20%+ growth
                score += 10
            elif revenue_growth > 0.10:  # 10%+ growth
                score += 5
            elif revenue_growth < 0:  # Negative growth
                score -= 10
        
        # Profit Margin (5 points)
        profit_margin = fundamental_data.get('profit_margin')
        if profit_margin is not None:
            if profit_margin > 0.20:  # 20%+ margin
                score += 5
            elif profit_margin < 0:  # Negative margin
                score -= 5
    
    # Ensure score is in range
    score = max(0, min(100, score))
    
    # ========================================
    # GENERATE SIGNAL & RECOMMENDATION
    # ========================================
    
    if score >= 80:
        signal = "BUY"
        recommendation = "Strong Buy"
    elif score >= 70:
        signal = "BUY"
        recommendation = "Buy"
    elif score >= 55:
        signal = "HOLD"
        recommendation = "Moderate Buy"
    elif score >= 45:
        signal = "HOLD"
        recommendation = "Neutral"
    elif score >= 30:
        signal = "HOLD"
        recommendation = "Moderate Sell"
    elif score >= 20:
        signal = "SELL"
        recommendation = "Sell"
    else:
        signal = "SELL"
        recommendation = "Strong Sell"
    
    return int(score), signal, recommendation

def calculate_stop_loss(close: float, sma_20: float, atr: Optional[float] = None) -> float:
    """
    Calculate recommended stop loss price
    
    Args:
        close: Current price
        sma_20: 20-day SMA
        atr: Average True Range (optional)
    
    Returns:
        Stop loss price
    """
    # Method 1: 2% below SMA20
    stop_loss_sma = sma_20 * 0.98
    
    # Method 2: 3% below current price (conservative)
    stop_loss_price = close * 0.97
    
    # Use the more conservative (higher) stop loss
    stop_loss = max(stop_loss_sma, stop_loss_price)
    
    return round(stop_loss, 2)

def calculate_target_price(close: float, score: int, resistance: Optional[float] = None) -> float:
    """
    Calculate target price based on score and technical levels
    
    Args:
        close: Current price
        score: Expert score
        resistance: Resistance level (optional)
    
    Returns:
        Target price
    """
    if score >= 80:
        multiplier = 1.15  # 15% upside
    elif score >= 70:
        multiplier = 1.10  # 10% upside
    elif score >= 60:
        multiplier = 1.05  # 5% upside
    else:
        multiplier = 1.02  # 2% upside
    
    target = close * multiplier
    
    return round(target, 2)

# ============================================================================
# STOCK ANALYSIS ENGINE
# ============================================================================

def analyze_stock(
    ticker: str,
    rsi_low: int = 30,
    rsi_high: int = 70,
    api_key: str = "",
    perplexity_key: str = "",
    account_size: float = 10000,
    risk_percent: float = 2.0
) -> Optional[Dict]:
    """
    Analyze a stock with expert-level scoring + risk management + AI insights
    
    Args:
        ticker: Stock ticker symbol
        rsi_low: RSI oversold threshold
        rsi_high: RSI overbought threshold
        api_key: Alpha Vantage API key (optional)
        perplexity_key: Perplexity API key (optional)
        account_size: Account size for position sizing
        risk_percent: Risk percentage per trade
    
    Returns:
        Dictionary with comprehensive analysis results
    """
    df = fetch_stock_data(ticker, period="3mo")
    
    if df is None or df.empty:
        return None
    
    # Calculate technical indicators
    df['RSI'] = calculate_rsi(df['Close'])
    df['SMA_20'] = calculate_sma(df['Close'], 20)
    df['SMA_50'] = calculate_sma(df['Close'], 50)
    df['ATR'] = calculate_atr(df['High'], df['Low'], df['Close'])
    
    # Get latest values
    latest = df.iloc[-1]
    rsi = latest['RSI']
    close = latest['Close']
    volume = latest['Volume']
    sma_20 = latest['SMA_20']
    sma_50 = latest['SMA_50']
    atr = latest['ATR']
    
    # Volume and breakout detection
    volume_spike = detect_volume_spike(df['Volume'])
    breakout = detect_breakout(df['Close'], df['High'])
    
    # Fetch fundamental data
    fundamental_data = fetch_fundamental_data(ticker, api_key)
    
    # Calculate expert score
    score, signal, recommendation = calculate_expert_score(
        rsi=rsi,
        close=close,
        sma_20=sma_20,
        sma_50=sma_50,
        volume_spike=volume_spike,
        breakout=breakout,
        fundamental_data=fundamental_data,
        rsi_low=rsi_low,
        rsi_high=rsi_high
    )
    
    # Calculate ATR-based stop loss
    atr_stop_loss = calculate_atr_stop_loss(close, atr, multiplier=1.5)
    
    # Calculate position sizing
    position_info = calculate_position_size(
        account_size=account_size,
        risk_percent=risk_percent,
        entry_price=close,
        stop_loss=atr_stop_loss
    )
    
    # Calculate target price
    target_price = calculate_target_price(close, score)
    
    # Calculate risk/reward ratio
    risk = close - atr_stop_loss
    reward = target_price - close
    risk_reward_ratio = reward / risk if risk > 0 else 0
    
    # Fetch AI sentiment (optional)
    ai_sentiment = fetch_ai_sentiment(ticker, perplexity_key) if perplexity_key else None
    
    result = {
        'ticker': ticker,
        'close': round(close, 2),
        'score': score,
        'recommendation': recommendation,
        'signal': signal,
        'rsi': round(rsi, 2),
        'volume': int(volume),
        'sma_20': round(sma_20, 2),
        'sma_50': round(sma_50, 2),
        'atr': round(atr, 2),
        'volume_spike': volume_spike,
        'breakout': breakout,
        'atr_stop_loss': atr_stop_loss,
        'target_price': target_price,
        'risk_reward_ratio': round(risk_reward_ratio, 2),
        'position_shares': position_info['shares'],
        'position_value': position_info['position_value'],
        'risk_amount': position_info['risk_amount'],
        'ai_sentiment': ai_sentiment
    }
    
    # Add fundamental data if available
    if fundamental_data:
        result['pe_ratio'] = fundamental_data.get('pe_ratio')
        result['peg_ratio'] = fundamental_data.get('peg_ratio')
        result['revenue_growth'] = fundamental_data.get('revenue_growth')
        result['profit_margin'] = fundamental_data.get('profit_margin')
        result['fundamental_source'] = fundamental_data.get('source', 'unknown')
    
    return result

def run_screener(
    tickers: List[str],
    rsi_low: int,
    rsi_high: int,
    api_key: str = "",
    perplexity_key: str = "",
    account_size: float = 10000,
    risk_percent: float = 2.0
) -> List[Dict]:
    """Run stock screener on multiple tickers with pro analysis"""
    results = []
    
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    for idx, ticker in enumerate(tickers):
        status_text.text(f"Analyzing {ticker}... ({idx + 1}/{len(tickers)})")
        result = analyze_stock(
            ticker, rsi_low, rsi_high, api_key,
            perplexity_key, account_size, risk_percent
        )
        
        if result:
            results.append(result)
        
        # Sleep to prevent API rate limiting
        if idx < len(tickers) - 1:  # Don't sleep on last iteration
            time.sleep(1.2)
        
        progress_bar.progress((idx + 1) / len(tickers))
    
    progress_bar.empty()
    status_text.empty()
    
    return results

# ============================================================================
# VISUALIZATION COMPONENTS
# ============================================================================

def render_sentiment_gauge(avg_sentiment: float):
    """
    Render sentiment gauge chart
    
    Args:
        avg_sentiment: Average sentiment value between -1 and 1
    """
    # Convert sentiment to 0-100 scale
    gauge_value = (avg_sentiment + 1) * 50  # -1 to 1 becomes 0 to 100
    
    # Determine color based on sentiment
    if gauge_value >= 60:
        color = "green"
        sentiment_label = "Positive"
    elif gauge_value >= 40:
        color = "orange"
        sentiment_label = "Neutral"
    else:
        color = "red"
        sentiment_label = "Negative"
    
    fig = go.Figure(go.Indicator(
        mode="gauge+number+delta",
        value=gauge_value,
        domain={'x': [0, 1], 'y': [0, 1]},
        title={'text': f"Overall Sentiment<br><span style='font-size:0.8em'>{sentiment_label}</span>"},
        delta={'reference': 50},
        gauge={
            'axis': {'range': [None, 100]},
            'bar': {'color': color},
            'steps': [
                {'range': [0, 33], 'color': "rgba(255, 0, 0, 0.2)"},
                {'range': [33, 66], 'color': "rgba(255, 165, 0, 0.2)"},
                {'range': [66, 100], 'color': "rgba(0, 255, 0, 0.2)"}
            ],
            'threshold': {
                'line': {'color': "black", 'width': 4},
                'thickness': 0.75,
                'value': 50
            }
        }
    ))
    
    fig.update_layout(
        height=250,
        margin=dict(l=20, r=20, t=50, b=20),
        paper_bgcolor="rgba(0,0,0,0)",
        font={'color': "gray", 'family': "Arial"}
    )
    
    st.plotly_chart(fig, use_container_width=True)

def render_candlestick_chart(ticker: str, period: str = "3mo"):
    """Render interactive candlestick chart with indicators"""
    df = fetch_stock_data(ticker, period)
    
    if df is None or df.empty:
        st.warning(f"No data available for {ticker}")
        return
    
    # Calculate indicators
    df['RSI'] = calculate_rsi(df['Close'])
    df['SMA_20'] = calculate_sma(df['Close'], 20)
    df['SMA_50'] = calculate_sma(df['Close'], 50)
    
    # Create subplots
    fig = make_subplots(
        rows=2, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.03,
        row_heights=[0.7, 0.3],
        subplot_titles=(f'{ticker} Price Chart', 'RSI')
    )
    
    # Candlestick chart
    fig.add_trace(
        go.Candlestick(
            x=df.index,
            open=df['Open'],
            high=df['High'],
            low=df['Low'],
            close=df['Close'],
            name='Price'
        ),
        row=1, col=1
    )
    
    # Moving averages
    fig.add_trace(
        go.Scatter(
            x=df.index,
            y=df['SMA_20'],
            name='SMA 20',
            line=dict(color='orange', width=1)
        ),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Scatter(
            x=df.index,
            y=df['SMA_50'],
            name='SMA 50',
            line=dict(color='blue', width=1)
        ),
        row=1, col=1
    )
    
    # RSI
    fig.add_trace(
        go.Scatter(
            x=df.index,
            y=df['RSI'],
            name='RSI',
            line=dict(color='purple', width=1.5)
        ),
        row=2, col=1
    )
    
    # RSI reference lines
    fig.add_hline(y=70, line_dash="dash", line_color="red", row=2, col=1)
    fig.add_hline(y=30, line_dash="dash", line_color="green", row=2, col=1)
    
    # Update layout - MOBILE OPTIMIZED HEIGHT
    fig.update_layout(
        height=300,  # Reduced height for mobile
        xaxis_rangeslider_visible=False,
        hovermode='x unified',
        template='plotly_white',
        showlegend=True,
        margin=dict(l=40, r=40, t=40, b=40),
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1
        )
    )
    
    fig.update_yaxes(title_text="Price ($)", row=1, col=1)
    fig.update_yaxes(title_text="RSI", row=2, col=1)
    
    st.plotly_chart(fig, use_container_width=True)

def render_score_history_chart(df_history: pd.DataFrame):
    """Render score trend over time"""
    if df_history.empty:
        st.info("No historical data available")
        return
    
    fig = go.Figure()
    
    fig.add_trace(go.Scatter(
        x=df_history['scan_time'],
        y=df_history['score'],
        mode='lines+markers',
        name='Score',
        line=dict(color='blue', width=2),
        marker=dict(size=6)
    ))
    
    fig.update_layout(
        title='Score History',
        xaxis_title='Date',
        yaxis_title='Score',
        height=300,  # Mobile optimized
        template='plotly_white',
        margin=dict(l=40, r=40, t=40, b=40)
    )
    
    st.plotly_chart(fig, use_container_width=True)

# ============================================================================
# UI COMPONENTS
# ============================================================================

def init_session_state():
    """Initialize Streamlit session state"""
    if 'selected_ticker' not in st.session_state:
        st.session_state.selected_ticker = None
    
    if 'scan_results' not in st.session_state:
        st.session_state.scan_results = None
    
    if 'scan_time' not in st.session_state:
        st.session_state.scan_time = None
    
    if 'db_manager' not in st.session_state:
        st.session_state.db_manager = DatabaseManager()

def render_sidebar_controls() -> Dict:
    """Render sidebar controls and return user selections"""
    st.sidebar.header("‚öôÔ∏è Pro Controls")
    
    # Risk Management Section
    st.sidebar.markdown("---")
    st.sidebar.subheader("üí∞ Risk Management")
    
    account_size = st.sidebar.number_input(
        "Account Size ($)",
        min_value=1000,
        max_value=10000000,
        value=10000,
        step=1000,
        help="Total trading account size in dollars"
    )
    
    risk_percent = st.sidebar.slider(
        "Risk % per Trade",
        min_value=0.5,
        max_value=5.0,
        value=2.0,
        step=0.5,
        help="Maximum percentage of account to risk on a single trade"
    )
    
    st.sidebar.info(f"üí° Max risk per trade: ${account_size * (risk_percent/100):,.2f}")
    
    # Perplexity AI Section
    st.sidebar.markdown("---")
    st.sidebar.subheader("ü§ñ AI Insights")
    
    with st.sidebar.expander("‚ÑπÔ∏è About Perplexity AI"):
        st.markdown("""
        **Perplexity AI** provides:
        - Real-time sentiment analysis
        - Latest earnings insights
        - Analyst rating summaries
        - News-based outlook
        
        üÜì Get API key: [perplexity.ai](https://www.perplexity.ai/)
        """)
    
    perplexity_key = st.sidebar.text_input(
        "Perplexity API Key (Optional)",
        type="password",
        help="Enter Perplexity API key for AI-powered sentiment"
    )
    
    if perplexity_key:
        st.sidebar.success("‚úÖ AI Insights Enabled")
    else:
        st.sidebar.info("üí° Add key for AI analysis")
    
    # Alpha Vantage Section
    st.sidebar.markdown("---")
    st.sidebar.subheader("üî¨ Fundamentals")
    
    with st.sidebar.expander("‚ÑπÔ∏è About Fundamental Data"):
        st.markdown("""
        **Expert Mode** adds:
        - P/E & PEG Ratios
        - Revenue Growth
        - Profit Margins
        
        **Without API:**
        - Uses Yahoo Finance (basic)
        
        **With API:**
        - Alpha Vantage (premium)
        - 24-hour caching
        
        üÜì Get key: [alphavantage.co](https://www.alphavantage.co/support/#api-key)
        """)
    
    api_key = st.sidebar.text_input(
        "Alpha Vantage API Key (Optional)",
        type="password",
        help="Enter Alpha Vantage API key for premium fundamentals"
    )
    
    if api_key:
        st.sidebar.success("‚úÖ Premium Fundamentals")
    else:
        st.sidebar.info("üí° Using Yahoo Finance")
    
    # Watchlist Section
    st.sidebar.markdown("---")
    st.sidebar.subheader("üìù Custom Watchlist")
    
    watchlist_input = st.sidebar.text_area(
        "Enter tickers (comma-separated)",
        value="",
        height=80,
        placeholder="NVDA, AAPL, TSLA, GOOGL",
        help="Enter stock tickers separated by commas"
    )
    
    custom_tickers = clean_ticker_list(watchlist_input)
    
    if custom_tickers:
        st.sidebar.success(f"‚úì {len(custom_tickers)} tickers loaded")
        with st.sidebar.expander("View Watchlist"):
            st.write(", ".join(custom_tickers))
    
    st.sidebar.markdown("---")
    
    # Default tickers
    default_tickers = [
        'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA',
        'NVDA', 'META', 'BRK-B', 'V', 'JPM',
        'JNJ', 'WMT', 'PG', 'MA', 'HD',
        'DIS', 'NFLX', 'PYPL', 'INTC', 'CSCO'
    ]
    
    if custom_tickers:
        selected_tickers = custom_tickers
        st.sidebar.info("Using custom watchlist")
    else:
        selected_tickers = st.sidebar.multiselect(
            "üìä Or Select from Defaults",
            options=default_tickers,
            default=default_tickers[:5],
            help="Choose stocks to analyze"
        )
    
    # RSI Settings
    st.sidebar.markdown("---")
    st.sidebar.subheader("üìà RSI Settings")
    rsi_low = st.sidebar.slider(
        "Oversold Threshold",
        min_value=10,
        max_value=40,
        value=30,
        help="Below = oversold (buy signal)"
    )
    
    rsi_high = st.sidebar.slider(
        "Overbought Threshold",
        min_value=60,
        max_value=90,
        value=70,
        help="Above = overbought (sell signal)"
    )
    
    st.sidebar.markdown("---")
    
    # Run scan button
    run_scan = st.sidebar.button(
        "üöÄ Run Pro Scan",
        type="primary",
        use_container_width=True
    )
    
    # Info section
    st.sidebar.markdown("---")
    st.sidebar.markdown("""
    ### üìå Pro Features
    ‚úÖ **ATR-Based Stop Loss**
    - Dynamic 1.5√ó ATR calculation
    
    ‚úÖ **Position Sizing**
    - Exact shares to buy
    - Risk-adjusted sizing
    
    ‚úÖ **AI Sentiment**
    - Perplexity-powered
    - Real-time insights
    
    ‚úÖ **Trend Tracking**
    - Google Sheets sync
    - 7-day sparklines
    
    üí° *1.2s delay for stability*
    """)
    
    return {
        'selected_tickers': selected_tickers,
        'rsi_low': rsi_low,
        'rsi_high': rsi_high,
        'run_scan_clicked': run_scan,
        'api_key': api_key,
        'perplexity_key': perplexity_key,
        'account_size': account_size,
        'risk_percent': risk_percent
    }

def render_metrics(stock_data: Dict):
    """Render KPI metrics for selected stock with card-style design"""
    
    # Custom CSS for metric cards
    st.markdown("""
    <style>
    div[data-testid="stMetricValue"] {
        font-size: 24px;
        font-weight: bold;
    }
    
    div[data-testid="stMetricLabel"] {
        font-size: 14px;
        color: #555;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Create card-style metrics
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        price = stock_data.get('close', 0)
        st.metric(
            label="üí∞ Current Price",
            value=f"${price:.2f}",
            help="Latest closing price"
        )
    
    with col2:
        score = stock_data.get('score', 0)
        
        # Color indicator
        if score >= 70:
            score_emoji = "üü¢"
        elif score <= 30:
            score_emoji = "üî¥"
        else:
            score_emoji = "üü°"
        
        st.metric(
            label="üìä Analysis Score",
            value=f"{score_emoji} {score}/100",
            help="Composite technical score"
        )
    
    with col3:
        rsi = stock_data.get('rsi', 50)
        
        if rsi < 30:
            rsi_status = "Oversold"
            rsi_delta = "üìâ"
        elif rsi > 70:
            rsi_status = "Overbought"
            rsi_delta = "üìà"
        else:
            rsi_status = "Neutral"
            rsi_delta = "‚û°Ô∏è"
        
        st.metric(
            label=f"{rsi_delta} RSI",
            value=f"{rsi:.1f}",
            delta=rsi_status,
            help="Relative Strength Index"
        )
    
    with col4:
        signal = stock_data.get('signal', 'HOLD')
        
        if signal == 'BUY':
            signal_emoji = "üü¢"
            signal_color = "#28a745"
        elif signal == 'SELL':
            signal_emoji = "üî¥"
            signal_color = "#dc3545"
        else:
            signal_emoji = "üü°"
            signal_color = "#ffc107"
        
        st.markdown(f"""
        <div style="
            text-align: center;
            padding: 10px;
            background-color: {signal_color}22;
            border-radius: 8px;
            border: 2px solid {signal_color};
        ">
            <div style="font-size: 12px; color: #555; margin-bottom: 4px;">
                Trading Signal
            </div>
            <div style="font-size: 28px; font-weight: bold; color: {signal_color};">
                {signal_emoji} {signal}
            </div>
        </div>
        """, unsafe_allow_html=True)

def render_stock_details(stock_data: Dict):
    """Render detailed stock information panel with risk management and AI insights"""
    st.subheader(f"üìã Details: {stock_data['ticker']}")
    
    # Create tabs for different information
    tab1, tab2, tab3, tab4 = st.tabs(["üìà Technical", "üíº Fundamentals", "‚ö†Ô∏è Risk Management", "ü§ñ AI Insights"])
    
    with tab1:
        st.markdown("**Technical Indicators:**")
        col1, col2 = st.columns(2)
        
        with col1:
            st.write(f"- RSI: {stock_data['rsi']:.2f}")
            st.write(f"- SMA 20: ${stock_data['sma_20']:.2f}")
            st.write(f"- SMA 50: ${stock_data['sma_50']:.2f}")
            st.write(f"- ATR: {stock_data.get('atr', 0):.2f}")
        
        with col2:
            st.write(f"- Volume: {stock_data['volume']:,}")
            st.write(f"- Volume Spike: {'üî• Yes' if stock_data.get('volume_spike') else '‚ùå No'}")
            st.write(f"- Breakout: {'üöÄ Yes' if stock_data.get('breakout') else '‚ùå No'}")
    
    with tab2:
        st.markdown("**Fundamental Metrics:**")
        
        if 'pe_ratio' in stock_data and stock_data['pe_ratio']:
            col1, col2 = st.columns(2)
            
            with col1:
                pe = stock_data.get('pe_ratio')
                st.metric("P/E Ratio", f"{pe:.2f}" if pe else "N/A")
                
                peg = stock_data.get('peg_ratio')
                st.metric("PEG Ratio", f"{peg:.2f}" if peg else "N/A")
            
            with col2:
                rev_growth = stock_data.get('revenue_growth')
                if rev_growth:
                    st.metric("Revenue Growth", f"{rev_growth*100:.1f}%")
                else:
                    st.metric("Revenue Growth", "N/A")
                
                profit_margin = stock_data.get('profit_margin')
                if profit_margin:
                    st.metric("Profit Margin", f"{profit_margin*100:.1f}%")
                else:
                    st.metric("Profit Margin", "N/A")
            
            # Data source indicator
            source = stock_data.get('fundamental_source', 'unknown')
            if source == 'alpha_vantage':
                st.success("‚úì Data from Alpha Vantage (Premium)")
            elif source == 'yfinance':
                st.info("‚ÑπÔ∏è Data from Yahoo Finance (Free)")
            else:
                st.warning("‚ö†Ô∏è Limited fundamental data available")
        else:
            st.info("üìä Fundamental data not available for this ticker")
    
    with tab3:
        st.markdown("**Professional Risk Management:**")
        
        # ATR Stop Loss
        if 'atr_stop_loss' in stock_data:
            atr_stop = stock_data['atr_stop_loss']
            current_price = stock_data['close']
            atr = stock_data.get('atr', 0)
            stop_loss_pct = ((current_price - atr_stop) / current_price) * 100
            
            st.markdown(f"""
            <div style="
                background-color: #fff3cd;
                padding: 15px;
                border-radius: 8px;
                border-left: 4px solid #ffc107;
                margin: 10px 0;
            ">
                <h4 style="margin-top: 0; color: #856404;">üõ°Ô∏è ATR-Based Stop Loss</h4>
                <p style="font-size: 24px; font-weight: bold; color: #856404; margin: 5px 0;">
                    ${atr_stop:.2f}
                </p>
                <p style="color: #856404; margin: 5px 0;">
                    Risk: {stop_loss_pct:.1f}% below current price
                </p>
                <p style="font-size: 12px; color: #666; margin-top: 10px;">
                    Calculated as: Price - (1.5 √ó ATR) = ${current_price:.2f} - (1.5 √ó ${atr:.2f})
                </p>
            </div>
            """, unsafe_allow_html=True)
        
        # Position Sizing
        if 'position_shares' in stock_data:
            shares = stock_data['position_shares']
            position_value = stock_data.get('position_value', 0)
            risk_amount = stock_data.get('risk_amount', 0)
            
            st.markdown(f"""
            <div style="
                background-color: #d1ecf1;
                padding: 15px;
                border-radius: 8px;
                border-left: 4px solid #17a2b8;
                margin: 10px 0;
            ">
                <h4 style="margin-top: 0; color: #0c5460;">üí∞ Recommended Position Size</h4>
                <p style="font-size: 24px; font-weight: bold; color: #0c5460; margin: 5px 0;">
                    {shares} shares
                </p>
                <p style="color: #0c5460; margin: 5px 0;">
                    Position Value: ${position_value:,.2f}
                </p>
                <p style="color: #0c5460; margin: 5px 0;">
                    Maximum Risk: ${risk_amount:,.2f}
                </p>
                <p style="font-size: 12px; color: #666; margin-top: 10px;">
                    Based on your account size and risk % per trade
                </p>
            </div>
            """, unsafe_allow_html=True)
        
        # Target Price
        if 'target_price' in stock_data:
            target = stock_data['target_price']
            current_price = stock_data['close']
            upside_pct = ((target - current_price) / current_price) * 100
            
            st.markdown(f"""
            <div style="
                background-color: #d4edda;
                padding: 15px;
                border-radius: 8px;
                border-left: 4px solid #28a745;
                margin: 10px 0;
            ">
                <h4 style="margin-top: 0; color: #155724;">üéØ Target Price</h4>
                <p style="font-size: 24px; font-weight: bold; color: #155724; margin: 5px 0;">
                    ${target:.2f}
                </p>
                <p style="color: #155724; margin: 5px 0;">
                    Potential upside: {upside_pct:.1f}%
                </p>
            </div>
            """, unsafe_allow_html=True)
        
        # Risk/Reward Ratio
        if 'risk_reward_ratio' in stock_data and stock_data['risk_reward_ratio'] > 0:
            rr_ratio = stock_data['risk_reward_ratio']
            
            rr_color = "#28a745" if rr_ratio >= 2 else "#ffc107" if rr_ratio >= 1 else "#dc3545"
            rr_status = "Excellent" if rr_ratio >= 2 else "Good" if rr_ratio >= 1 else "Poor"
            
            st.markdown(f"""
            <div style="
                background-color: {rr_color}22;
                padding: 15px;
                border-radius: 8px;
                border-left: 4px solid {rr_color};
                margin: 10px 0;
            ">
                <h4 style="margin-top: 0; color: {rr_color};">üìä Risk/Reward Ratio</h4>
                <p style="font-size: 24px; font-weight: bold; color: {rr_color}; margin: 5px 0;">
                    {rr_ratio:.2f}:1
                </p>
                <p style="color: {rr_color}; margin: 5px 0;">
                    Rating: {rr_status}
                </p>
                <p style="font-size: 12px; color: #666; margin-top: 10px;">
                    Professional trades typically have R/R ratio of 2:1 or better
                </p>
            </div>
            """, unsafe_allow_html=True)
        
        # Trading recommendation
        recommendation = stock_data.get('recommendation', 'Neutral')
        if recommendation in ['Strong Buy', 'Buy']:
            st.success(f"‚úÖ **Expert Recommendation:** {recommendation}")
            st.info("üí° Enter position with calculated share size and set stop loss immediately")
        elif recommendation == 'Neutral':
            st.warning(f"‚ö†Ô∏è **Expert Recommendation:** {recommendation}")
            st.info("üí° Wait for better entry point or stronger signals")
        else:
            st.error(f"üö´ **Expert Recommendation:** {recommendation}")
            st.info("üí° Avoid entering position or consider exiting if you hold")
    
    with tab4:
        st.markdown("**AI-Powered Sentiment Analysis:**")
        
        # Display AI sentiment if available
        if 'ai_sentiment' in stock_data and stock_data['ai_sentiment']:
            st.markdown(f"""
            <div style="
                background-color: #e7f3ff;
                padding: 15px;
                border-radius: 8px;
                border-left: 4px solid #2196F3;
                margin: 10px 0;
            ">
                <h4 style="margin-top: 0; color: #1565C0;">ü§ñ Perplexity AI Analysis</h4>
                <p style="color: #333; line-height: 1.6;">
                    {stock_data['ai_sentiment']}
                </p>
                <p style="font-size: 11px; color: #666; margin-top: 10px;">
                    Based on latest earnings reports, analyst ratings, and recent news
                </p>
            </div>
            """, unsafe_allow_html=True)
        else:
            st.info("üí° Enable Perplexity AI in sidebar to get AI-powered sentiment analysis")
            st.markdown("""
            **What you'll get:**
            - Real-time sentiment from latest news
            - Earnings report analysis
            - Analyst rating summaries
            - Fundamental outlook (2-3 sentences)
            """)
        
        # Market context
        st.markdown("---")
        st.markdown("**üì∞ Manual Research Checklist:**")
        ticker = stock_data['ticker']
        st.markdown(f"""
        - [ ] Check latest earnings on [Yahoo Finance](https://finance.yahoo.com/quote/{ticker})
        - [ ] Review analyst ratings on [MarketWatch](https://www.marketwatch.com/investing/stock/{ticker})
        - [ ] Read recent news on [Seeking Alpha](https://seekingalpha.com/symbol/{ticker})
        - [ ] Check SEC filings on [EDGAR](https://www.sec.gov/cgi-bin/browse-edgar?action=getcompany&CIK={ticker})
        """)

def render_results_table(df_results: pd.DataFrame, gsheets_conn: Optional[GSheetsConnection] = None):
    """Render interactive results table with expert recommendations, sparklines, and CSS styling"""
    if df_results.empty:
        st.info("No results to display. Run a scan to get started!")
        return
    
    # Add custom CSS for recommendation highlighting
    st.markdown("""
    <style>
    /* Style for recommendation cells */
    [data-testid="stDataFrame"] [data-testid="stDataFrameResizable"] {
        font-family: 'Arial', sans-serif;
    }
    
    /* Color coding for recommendations */
    .strong-buy {
        background-color: #1e7e34 !important;
        color: white !important;
        font-weight: bold;
    }
    
    .buy-signal {
        background-color: #28a745 !important;
        color: white !important;
        font-weight: bold;
    }
    
    .moderate-buy {
        background-color: #8bc34a !important;
        color: #1b5e20 !important;
    }
    
    .neutral-signal {
        background-color: #ffc107 !important;
        color: #856404 !important;
    }
    
    .moderate-sell {
        background-color: #ff9800 !important;
        color: #4e2c00 !important;
    }
    
    .sell-signal {
        background-color: #dc3545 !important;
        color: white !important;
    }
    
    .strong-sell {
        background-color: #8b0000 !important;
        color: white !important;
        font-weight: bold;
    }
    </style>
    """, unsafe_allow_html=True)
    
    st.subheader("üìä Pro Analysis Results")
    
    # Display summary stats with expert analysis
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        strong_buy = len(df_results[df_results['recommendation'] == 'Strong Buy'])
        st.metric("üü¢ Strong Buy", strong_buy)
    
    with col2:
        buy_count = len(df_results[df_results['recommendation'].isin(['Buy', 'Moderate Buy'])])
        st.metric("‚úÖ Buy", buy_count)
    
    with col3:
        neutral_count = len(df_results[df_results['recommendation'] == 'Neutral'])
        st.metric("üü° Neutral", neutral_count)
    
    with col4:
        sell_count = len(df_results[df_results['recommendation'].isin(['Sell', 'Moderate Sell'])])
        st.metric("‚ö†Ô∏è Sell", sell_count)
    
    with col5:
        avg_score = df_results['score'].mean()
        st.metric("üìä Avg Score", f"{avg_score:.1f}")
    
    st.markdown("---")
    
    # Prepare display dataframe with sparklines
    display_data = []
    
    for _, row in df_results.iterrows():
        ticker = row['ticker']
        
        # Get score history for sparkline
        if gsheets_conn:
            history_df = get_score_history_gsheets(gsheets_conn, ticker, days=7)
            if not history_df.empty:
                scores = history_df['Score'].tolist()
                sparkline = create_sparkline(scores)
                ticker_with_spark = f"{ticker} {sparkline}"
            else:
                ticker_with_spark = ticker
        else:
            ticker_with_spark = ticker
        
        display_data.append({
            'Ticker': ticker_with_spark,
            'Price': f"${row['close']:.2f}",
            'Score': int(row['score']),
            'Expert Rec': row['recommendation'],
            'Signal': row['signal'],
            'RSI': f"{row['rsi']:.1f}",
            'ATR': f"{row.get('atr', 0):.2f}",
            'Position': f"{row.get('position_shares', 0)} shares",
            'R/R': f"{row.get('risk_reward_ratio', 0):.2f}" if row.get('risk_reward_ratio', 0) > 0 else "N/A"
        })
    
    final_df = pd.DataFrame(display_data)
    
    # Display with selection
    st.dataframe(
        final_df,
        use_container_width=True,
        hide_index=True,
        selection_mode="single-row",
        on_select="rerun",
        key="results_table",
        column_config={
            "Ticker": st.column_config.TextColumn("Ticker", width="medium", help="7-day trend sparkline"),
            "Price": st.column_config.TextColumn("Price", width="small"),
            "Score": st.column_config.NumberColumn("Score", width="small"),
            "Expert Rec": st.column_config.TextColumn("Expert Rec", width="medium"),
            "Signal": st.column_config.TextColumn("Signal", width="small"),
            "RSI": st.column_config.TextColumn("RSI", width="small"),
            "ATR": st.column_config.TextColumn("ATR", width="small", help="Average True Range"),
            "Position": st.column_config.TextColumn("Position", width="medium", help="Recommended shares"),
            "R/R": st.column_config.TextColumn("R/R", width="small", help="Risk/Reward Ratio")
        }
    )
    
    # Color legend
    st.markdown("""
    **Legend:**  
    üü¢ **Strong Buy** (Score 80+) | ‚úÖ **Buy** (70-79) | üü¢ **Moderate Buy** (55-69) |  
    üü° **Neutral** (45-54) | üü† **Moderate Sell** (30-44) | üî¥ **Sell** (20-29) | ‚õî **Strong Sell** (<20)
    
    üìà **Sparkline** shows 7-day score trend (green=up, red=down)
    """)
    
    # Handle selection
    if st.session_state.get('results_table'):
        selection = st.session_state.results_table.get('selection')
        if selection and selection.get('rows'):
            selected_idx = selection['rows'][0]
            selected_ticker = df_results.iloc[selected_idx]['ticker']
            st.session_state.selected_ticker = selected_ticker

def render_history_view():
    """Render historical scan viewer"""
    st.markdown("---")
    st.subheader("üìú Historical Scan Data")
    
    db_manager = st.session_state.db_manager
    
    # Check if we have any data
    latest_scan = db_manager.load_latest_scan()
    
    if latest_scan.empty:
        st.info("No historical data yet. Run a scan to start tracking!")
        return
    
    # Get unique tickers from latest scan
    tickers = sorted(latest_scan['ticker'].unique().tolist())
    
    selected_history_ticker = st.selectbox(
        "Select Ticker for History",
        options=tickers,
        key="history_ticker"
    )
    
    if selected_history_ticker:
        df_history = db_manager.load_history(selected_history_ticker)
        
        if not df_history.empty:
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("**üìä Recent Scan Results:**")
                
                # Format the history dataframe with clear English headers
                display_history = df_history.copy()
                display_history['Scan Time'] = display_history['scan_time']
                display_history['Price'] = display_history['close'].apply(lambda x: f"${x:.2f}")
                display_history['Score'] = display_history['score'].astype(int)
                display_history['Signal'] = display_history['signal']
                display_history['RSI'] = display_history['rsi'].apply(lambda x: f"{x:.1f}")
                
                # Select columns for display
                final_display = display_history[['Scan Time', 'Price', 'Score', 'Signal', 'RSI']].head(10)
                
                st.dataframe(
                    final_display,
                    hide_index=True,
                    use_container_width=True,
                    column_config={
                        "Scan Time": st.column_config.TextColumn("Scan Time", width="medium"),
                        "Price": st.column_config.TextColumn("Price", width="small"),
                        "Score": st.column_config.NumberColumn("Score", width="small"),
                        "Signal": st.column_config.TextColumn("Signal", width="small"),
                        "RSI": st.column_config.TextColumn("RSI", width="small")
                    }
                )
            
            with col2:
                render_score_history_chart(df_history)
        else:
            st.info(f"No history available for {selected_history_ticker}")

# ============================================================================
# MAIN APPLICATION
# ============================================================================

def main():
    """Main application entry point"""
    
    # Page configuration
    st.set_page_config(
        page_title="Stock Trading Dashboard",
        page_icon="üìà",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    
    # Custom CSS for mobile optimization
    st.markdown("""
    <style>
    /* Mobile-friendly padding */
    .main .block-container {
        padding-top: 2rem;
        padding-bottom: 2rem;
    }
    
    /* Card-style containers */
    .card {
        background-color: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        margin: 10px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* BUY signal highlighting */
    .buy-highlight {
        background-color: #d4edda !important;
        padding: 10px;
        border-radius: 8px;
        border-left: 4px solid #28a745;
    }
    
    /* Responsive font sizes */
    @media (max-width: 768px) {
        h1 { font-size: 24px !important; }
        h2 { font-size: 20px !important; }
        h3 { font-size: 18px !important; }
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Initialize session state
    init_session_state()
    
    # Header with card design
    st.markdown("""
    <div style="
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
    ">
        <h1 style="color: white; margin: 0; text-align: center;">
            üìà Stock Trading Dashboard
        </h1>
        <p style="color: #e0e0e0; text-align: center; margin: 10px 0 0 0;">
            Pro Edition ‚Ä¢ ATR Stop Loss ‚Ä¢ Position Sizing ‚Ä¢ AI Insights ‚Ä¢ Trend Tracking
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Render sidebar and get controls
    controls = render_sidebar_controls()
    
    # Initialize Google Sheets connection
    gsheets_conn = init_gsheets_connection()
    
    # Main content area
    db_manager = st.session_state.db_manager
    
    # Handle scan execution
    if controls['run_scan_clicked']:
        if not controls['selected_tickers']:
            st.warning("‚ö†Ô∏è Please select at least one ticker to scan")
        else:
            # Show pro mode status
            status_items = []
            if controls['perplexity_key']:
                status_items.append("ü§ñ AI Insights")
            if controls['api_key']:
                status_items.append("üî¨ Premium Fundamentals")
            status_items.append(f"üí∞ Risk: {controls['risk_percent']}%")
            status_items.append("üìä ATR Stop Loss")
            
            st.info(f"**Pro Mode Active:** {' | '.join(status_items)}")
            
            with st.spinner("üîç Running professional stock screener..."):
                results = run_screener(
                    controls['selected_tickers'],
                    controls['rsi_low'],
                    controls['rsi_high'],
                    controls['api_key'],
                    controls['perplexity_key'],
                    controls['account_size'],
                    controls['risk_percent']
                )
                
                if results:
                    # Save to database
                    db_manager.save_scan_results(results)
                    
                    # Save scores to Google Sheets for trend tracking
                    if gsheets_conn:
                        current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        for result in results:
                            save_score_to_gsheets(
                                gsheets_conn,
                                result['ticker'],
                                result['score'],
                                current_date
                            )
                    
                    # Update session state
                    st.session_state.scan_results = pd.DataFrame(results)
                    st.session_state.scan_time = datetime.now()
                    
                    st.success(f"‚úÖ Pro scan completed! Analyzed {len(results)} stocks with ATR risk management")
                else:
                    st.error("‚ùå Scan failed. Please check your ticker symbols")
    
    # Load results (either from scan or from database)
    if st.session_state.scan_results is not None:
        df_results = st.session_state.scan_results
    else:
        df_results = db_manager.load_latest_scan()
        if not df_results.empty:
            st.session_state.scan_results = df_results
    
    # Display results table
    if not df_results.empty:
        # TOP CARD SECTION - Market Overview
        st.markdown("### üìä Market Overview")
        
        overview_col1, overview_col2, overview_col3 = st.columns([2, 2, 3])
        
        with overview_col1:
            # Summary stats card
            total_stocks = len(df_results)
            buy_signals = len(df_results[df_results['signal'] == 'BUY'])
            sell_signals = len(df_results[df_results['signal'] == 'SELL'])
            
            st.markdown(f"""
            <div class="card">
                <h4 style="margin-top: 0;">üìà Summary</h4>
                <p><strong>Total Stocks:</strong> {total_stocks}</p>
                <p><strong>üü¢ Buy Signals:</strong> {buy_signals}</p>
                <p><strong>üî¥ Sell Signals:</strong> {sell_signals}</p>
            </div>
            """, unsafe_allow_html=True)
        
        with overview_col2:
            # Top performers card
            top_stocks = df_results.nlargest(3, 'score')
            
            st.markdown("""
            <div class="card">
                <h4 style="margin-top: 0;">‚≠ê Top Performers</h4>
            """, unsafe_allow_html=True)
            
            for _, stock in top_stocks.iterrows():
                st.markdown(f"**{stock['ticker']}**: {stock['score']}/100")
            
            st.markdown("</div>", unsafe_allow_html=True)
        
        with overview_col3:
            # Sentiment gauge
            avg_sentiment = df_results['sentiment'].mean()
            render_sentiment_gauge(avg_sentiment)
        
        st.markdown("---")
        
        # Show scan time
        if st.session_state.scan_time:
            st.caption(f"üïí Last scan: {st.session_state.scan_time.strftime('%Y-%m-%d %H:%M:%S')}")
        elif 'scan_time' in df_results.columns:
            st.caption(f"üïí Last scan: {df_results['scan_time'].iloc[0]}")
        
        # Render table
        render_results_table(df_results, gsheets_conn)
        
        # If a stock is selected, show details
        if st.session_state.selected_ticker:
            selected_data = df_results[df_results['ticker'] == st.session_state.selected_ticker].iloc[0].to_dict()
            
            st.markdown("---")
            st.markdown(f"## üéØ Selected Stock: **{st.session_state.selected_ticker}**")
            
            # Metrics row with card design
            render_metrics(selected_data)
            
            st.markdown("---")
            
            # Details and chart
            col1, col2 = st.columns([1, 2])
            
            with col1:
                render_stock_details(selected_data)
            
            with col2:
                # Show chart for ANY selected stock (not just BUY signals)
                st.subheader(f"üìä Price Chart")
                
                period = st.selectbox(
                    "Time Period",
                    options=['1mo', '3mo', '6mo', '1y'],
                    index=1,
                    key="chart_period"
                )
                
                render_candlestick_chart(st.session_state.selected_ticker, period)
    
    else:
        # Empty state with helpful message
        st.markdown("""
        <div style="
            text-align: center;
            padding: 60px 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            margin: 40px 0;
        ">
            <h2>üëã Welcome to Your Trading Dashboard!</h2>
            <p style="font-size: 18px; color: #666; margin: 20px 0;">
                Get started by selecting stocks and running your first scan
            </p>
            <p style="color: #888;">
                üìå Use the sidebar to configure your watchlist and settings
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    # Historical viewer
    render_history_view()
    
    # Footer
    st.markdown("---")
    st.markdown("""
    <div style='text-align: center; color: gray; padding: 20px;'>
        <p><strong>üìä Stock Trading Dashboard v4.0 - Pro Edition</strong></p>
        <p style='font-size: 12px;'>
            ATR Stop Loss ‚Ä¢ Position Sizing ‚Ä¢ AI Insights ‚Ä¢ Trend Tracking
        </p>
        <p style='font-size: 12px;'>
            Built with Streamlit ‚Ä¢ Data: Yahoo Finance + Alpha Vantage + Perplexity AI
        </p>
        <p style='font-size: 11px; color: #999;'>
            ‚ö†Ô∏è Not financial advice ‚Ä¢ For educational purposes only
        </p>
    </div>
    """, unsafe_allow_html=True)

# ============================================================================
# RUN APPLICATION
# ============================================================================

if __name__ == "__main__":
    main()
 
